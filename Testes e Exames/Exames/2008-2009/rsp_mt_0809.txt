Resposta ao Miniteste A de ASOP 8 Junho 2009

1ª Parte

1- A (Aceitei também B, pois o enunciado não era suficientemente claro.)

2- C

3- E

4- D

5- B 

	
2ª Parte
	
1.1.
A função devolve o factorial do seu argumento.
Se o argumento for 4, é devolvido 24
i=2, res=2, ret=4*2=8
i=3, res=3, ret=8*3=24

1.2.
int foo(int n) {
	int i, fact=n;
	int res;
	pid_t pid;
	
	for (i=2; i<n; i++) {
		pid = fork();
		if (pid == 0) {
			exit(i);
		} else if (pid >0) {
			if (wait(&res) == -1) {
				perror("wait");
				exit(1);
			}
			fact *= WEXITSTATUS(res);
		} else { // i<0
			perror("fork");
			exit(1);
		}
	}
	return fact;
}

1.3.
int foo(int n) {
	int i, fact=n;
	int res;
	
	for (i=2; i<n; i++) {
	if (fork() == 0)
		exit(i);
	}

	for (i=2; i<n; i++) {
		wait(&res);
		fact *= WEXITSTATUS(res);
	}
	return fact;
}

2.1.

int main() {
  ctrl_t control = {23, 4, 1000, 10};

  pthread_t tid_fan, tid_temp;

  pthread_create(&tid_temp, NULL, temp, &control);
  pthread_create(&tid_fan, NULL, fan, &control);

	pthread_join(tid_temp, NULL);
	pthread_join(tid_fan, NULL);
}

2.2.

void * temp(void *arg) {
  ctrl_t *ct = (ctrl_t *) arg;
	
  while (1) {
		int ntemp = read_temperature();
		pthread_mutex_lock(&mut);
		ct->delta_temp = ntemp - ct->temp;
		ct->temp = ntemp;
		pthread_mutex_unlock(&mut);
		usleep(10000); // sleeps (blocks) during some time
  }
  return NULL;
}

void * fan(void *arg) {
  ctrl_t *ct = (ctrl_t *) arg;

  while (1) {
  	pthread_mutex_lock(&mut);
		while(ct->delta_temp < ct->threshold) {
			pthread_mutex_unlock(&mut);
			usleep(10000);
			pthread_mutex_lock(&mut);
		}
	
		ct->fan_speed += ct->delta_temp;
		set_fanspeed(ct->fan_speed);
		ct->threshold += ct->delta_temp;
		pthread_mutex_unlock(&mut);
		usleep(10000);
  }
  return NULL;
}

2.3.

void * temp(void *arg) {
  ctrl_t *ct = (ctrl_t *) arg;
	
  while (1) {
		int ntemp = read_temperature();
		pthread_mutex_lock(&mut);
		ct->delta_temp = ntemp - ct->temp;
		ct->temp = ntemp;
		pthread_mutex_unlock(&mut);
		if (ct->delta_temp >= ct->threshold // optional, increase eficiency
			pthread_cond_signal(&cond);
		usleep(10000); // sleeps (blocks) during some time
  }
  return NULL;
}

void * fan(void *arg) {
  ctrl_t *ct = (ctrl_t *) arg;

  while (1) {
  	pthread_mutex_lock(&mut);
		while(ct->delta_temp < ct->threshold) { // can be removed if the  optional
																						// statment in temp() is used
			pthread_cond_wait(&cond, &mut);
		}
	
		ct->fan_speed += ct->delta_temp;
		set_fanspeed(ct->fan_speed);
		ct->threshold += ct->delta_temp;
		pthread_mutex_unlock(&mut);
		usleep(10000);
  }
  return NULL;
}


